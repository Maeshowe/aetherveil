// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// https://mozilla.org/MPL/2.0/
// © Normalized Order Flow Anomaly Indicator v2.0

//@version=6
indicator("Order Flow Anomaly v2", shorttitle="OFA2", overlay=false, precision=2)

// ============================================================================
// DESIGN PHILOSOPHY (v2)
// ============================================================================
//
// KEY DISTINCTION:
// - MAGNITUDE = How strong is the activity? (absolute measurement)
// - ANOMALY = How unusual is this compared to recent history? (statistical rarity)
//
// This indicator measures ANOMALY, not magnitude.
// A score of +2 means "this is unusually bullish FOR THIS INSTRUMENT/TIMEFRAME"
// NOT "there is strong buying pressure in absolute terms"
//
// COMPOSITE LOGIC:
// The final score requires BOTH conditions:
// 1. Activity must be unusual (volume anomaly)
// 2. Direction must be unusual (imbalance anomaly)
//
// If volume is normal but imbalance is extreme → likely noise, not institutional
// If volume is extreme but imbalance is neutral → large but undirected activity
// Only when BOTH are anomalous do we flag potential institutional flow.
//
// ADAPTIVE THRESHOLDS:
// Fixed ±2σ thresholds fail across timeframes:
// - 1m charts: Too noisy, constant triggers
// - 15m+ charts: Too rare, miss signals
//
// Solution: Use percentile-based adaptive bands and state-change detection.
// ============================================================================

// ============================================================================
// MODULE 1: INPUT CONFIGURATION
// ============================================================================

string group_lookback = "Lookback Settings"
int imbalance_period = input.int(20, "Imbalance Lookback", minval=5, maxval=200, tooltip="Rolling window for imbalance calculation", group=group_lookback)
int zscore_period = input.int(50, "Z-Score Lookback", minval=20, maxval=500, tooltip="Rolling window for statistical normalization", group=group_lookback)
int seasonality_period = input.int(20, "Seasonality Lookback (days)", minval=5, maxval=100, tooltip="Historical days for time-of-day normalization", group=group_lookback)
int adaptive_period = input.int(100, "Adaptive Threshold Lookback", minval=50, maxval=500, tooltip="Lookback for percentile-based thresholds", group=group_lookback)

string group_season = "Seasonality Settings"
string bucket_option = input.string("15", "Time Bucket (minutes)", options=["1", "5", "15", "30", "60"], tooltip="Granularity for time-of-day bucketing", group=group_season)
int bucket_minutes = str.tonumber(bucket_option) > 0 ? int(str.tonumber(bucket_option)) : 15
bool use_seasonality = input.bool(true, "Enable Seasonality Normalization", tooltip="Disable for daily+ timeframes", group=group_season)

string group_anomaly = "Anomaly Detection"
float volume_anomaly_weight = input.float(0.5, "Volume Anomaly Weight", minval=0.0, maxval=1.0, step=0.1, tooltip="Weight for activity component", group=group_anomaly)
float direction_anomaly_weight = input.float(0.5, "Direction Anomaly Weight", minval=0.0, maxval=1.0, step=0.1, tooltip="Weight for directional component", group=group_anomaly)
bool use_multiplicative = input.bool(true, "Multiplicative Combination", tooltip="ON: Both anomalies required. OFF: Additive (traditional)", group=group_anomaly)
float anomaly_gate = input.float(1.0, "Anomaly Gate (σ)", minval=0.5, maxval=2.0, step=0.25, tooltip="Minimum Z-score for each component to contribute (multiplicative mode)", group=group_anomaly)

string group_adaptive = "Adaptive Thresholds"
bool use_adaptive = input.bool(true, "Use Adaptive Thresholds", tooltip="Dynamic thresholds based on recent score distribution", group=group_adaptive)
float alert_percentile = input.float(90.0, "Alert Percentile", minval=80.0, maxval=99.0, step=1.0, tooltip="Percentile for standard alert (e.g., 90 = top 10%)", group=group_adaptive)
float extreme_percentile = input.float(97.0, "Extreme Percentile", minval=90.0, maxval=99.9, step=0.5, tooltip="Percentile for extreme alert (e.g., 97 = top 3%)", group=group_adaptive)
float fixed_alert = input.float(2.0, "Fixed Alert Threshold", minval=1.0, maxval=4.0, step=0.5, tooltip="Used when adaptive is OFF", group=group_adaptive)
float fixed_extreme = input.float(3.0, "Fixed Extreme Threshold", minval=2.0, maxval=5.0, step=0.5, tooltip="Used when adaptive is OFF", group=group_adaptive)

string group_state = "State Detection"
bool use_state_detection = input.bool(true, "Enable State Detection", tooltip="Detect regime changes rather than absolute levels", group=group_state)
int state_smooth = input.int(5, "State Smoothing", minval=1, maxval=20, tooltip="EMA length for state detection", group=group_state)
float state_change_threshold = input.float(1.5, "State Change Sensitivity", minval=0.5, maxval=3.0, step=0.25, tooltip="How much score must change to trigger state shift", group=group_state)

string group_smooth = "Smoothing Settings"
bool use_smoothing = input.bool(true, "Enable Signal Smoothing", group=group_smooth)
int smooth_length = input.int(3, "Smoothing Length", minval=1, maxval=10, group=group_smooth)

string group_viz = "Visualization"
bool show_histogram = input.bool(true, "Show Histogram", group=group_viz)
bool show_components = input.bool(false, "Show Component Scores", tooltip="Display volume and direction anomalies separately", group=group_viz)
bool show_adaptive_bands = input.bool(true, "Show Adaptive Bands", group=group_viz)
color color_bullish = input.color(color.new(color.teal, 20), "Accumulation Color", group=group_viz)
color color_bearish = input.color(color.new(color.red, 20), "Distribution Color", group=group_viz)
color color_neutral = input.color(color.new(color.gray, 50), "Neutral Color", group=group_viz)
color color_extreme_bull = input.color(color.new(color.lime, 0), "Extreme Accumulation", group=group_viz)
color color_extreme_bear = input.color(color.new(color.maroon, 0), "Extreme Distribution", group=group_viz)

// ============================================================================
// MODULE 2: CONSTANTS & UTILITIES
// ============================================================================

var float EPSILON = 1e-10
var int MINUTES_PER_DAY = 1440

int tf_mult = timeframe.multiplier
int tf_in_minutes = timeframe.isdaily ? 1440 : timeframe.isweekly ? 10080 : timeframe.ismonthly ? 43200 : tf_mult
int bars_per_day = int(math.ceil(MINUTES_PER_DAY / math.max(1, tf_in_minutes)))

// ============================================================================
// MODULE 3: SIGNED VOLUME & RAW IMBALANCE
// ============================================================================

float candle_direction = close > open ? 1.0 : close < open ? -1.0 : (close > close[1] ? 1.0 : -1.0)
float signed_volume = volume * candle_direction

float sum_signed_volume = math.sum(signed_volume, imbalance_period)
float sum_total_volume = math.sum(volume, imbalance_period)
float imbalance = sum_signed_volume / (sum_total_volume + EPSILON)
float imbalance_clamped = math.max(-1.0, math.min(1.0, imbalance))

// ============================================================================
// MODULE 4: SEASONALITY NORMALIZATION
// ============================================================================

int current_minute = hour * 60 + minute
int current_bucket = int(math.floor(current_minute / bucket_minutes))
int max_lookback_days = int(math.min(seasonality_period, math.floor(bar_index / math.max(1, bars_per_day))))

var float seasonal_sum = 0.0
var int seasonal_count = 0
seasonal_sum := 0.0
seasonal_count := 0

for i = 1 to 50
    if i <= max_lookback_days
        int offset = i * bars_per_day
        if offset < bar_index and offset > 0
            float hist_vol = volume[offset]
            if not na(hist_vol) and hist_vol > 0
                seasonal_sum += hist_vol
                seasonal_count += 1

float seasonal_avg = seasonal_count > 0 ? seasonal_sum / float(seasonal_count) : volume
float vol_sma = ta.sma(volume, zscore_period)
float volume_normalized = na(vol_sma) ? 1.0 : (use_seasonality and seasonal_avg > EPSILON ? volume / seasonal_avg : volume / (vol_sma + EPSILON))

// ============================================================================
// MODULE 5: SEPARATE ANOMALY SCORES
// ============================================================================
//
// KEY INSIGHT: We calculate TWO independent anomaly scores:
//
// 1. ACTIVITY ANOMALY (|Z_volume|): How unusual is the volume level?
//    - Uses absolute value because we care about magnitude, not direction
//    - High = unusual activity (could be accumulation OR distribution)
//
// 2. DIRECTIONAL ANOMALY (Z_imbalance): How unusual is the buy/sell ratio?
//    - Signed value: positive = unusually bullish, negative = unusually bearish
//    - High absolute value = unusual directional bias
//
// The FINAL SCORE combines these with the logic:
// - Multiplicative: score = sign(direction) * |volume_anomaly| * |direction_anomaly|
//   → Only high when BOTH are anomalous
// - Additive: score = w1 * volume_anomaly + w2 * direction_anomaly (traditional)
// ============================================================================

// Z-score helper
zscore(float value, int period) =>
    float mu = ta.sma(value, period)
    float sigma = ta.stdev(value, period)
    float result = sigma > EPSILON ? (value - mu) / sigma : 0.0
    result

// Activity Anomaly: How unusual is the volume? (unsigned)
float z_volume_raw = zscore(volume_normalized, zscore_period)
float activity_anomaly = math.abs(z_volume_raw)

// Directional Anomaly: How unusual is the imbalance? (signed)
float direction_anomaly = zscore(imbalance_clamped, zscore_period)

// ============================================================================
// MODULE 6: COMPOSITE ANOMALY SCORE
// ============================================================================

// Normalize weights
float total_weight = volume_anomaly_weight + direction_anomaly_weight + EPSILON
float w_vol = volume_anomaly_weight / total_weight
float w_dir = direction_anomaly_weight / total_weight

// Calculate composite score based on combination mode
float composite_raw = 0.0

if use_multiplicative
    // Multiplicative: Both must exceed gate to contribute
    // Score = sign(direction) * sqrt(|activity| * |direction|) when both > gate
    // This ensures score is only high when BOTH conditions are anomalous
    float activity_gated = activity_anomaly > anomaly_gate ? activity_anomaly : 0.0
    float direction_gated = math.abs(direction_anomaly) > anomaly_gate ? math.abs(direction_anomaly) : 0.0

    if activity_gated > 0 and direction_gated > 0
        // Geometric mean preserves scale while requiring both
        float magnitude = math.sqrt(activity_gated * direction_gated)
        float direction_sign = direction_anomaly > 0 ? 1.0 : -1.0
        composite_raw := direction_sign * magnitude
    else
        // One or both below gate: reduced score
        composite_raw := direction_anomaly * 0.3  // Dampened directional signal only
else
    // Additive (traditional): Weighted sum
    // Note: activity_anomaly is unsigned, so we apply direction's sign
    float signed_activity = z_volume_raw > 0 ? activity_anomaly : -activity_anomaly
    composite_raw := w_vol * signed_activity + w_dir * direction_anomaly

// Apply smoothing
float composite_score = use_smoothing ? ta.ema(composite_raw, smooth_length) : composite_raw

// ============================================================================
// MODULE 7: ADAPTIVE THRESHOLDS
// ============================================================================
//
// Problem with fixed thresholds:
// - 1m BTC: ±2σ triggers 50+ times per day (too noisy)
// - 15m SPY: ±2σ triggers 2-3 times per week (too rare)
//
// Solution: Percentile-based adaptive bands
// - Alert threshold = X percentile of recent |score| distribution
// - Extreme threshold = Y percentile
//
// This auto-calibrates to each instrument/timeframe combination.
// ============================================================================

// Calculate adaptive thresholds using percentiles of absolute score
float abs_score = math.abs(composite_score)
float adaptive_alert_threshold = ta.percentile_linear_interpolation(abs_score, adaptive_period, alert_percentile)
float adaptive_extreme_threshold = ta.percentile_linear_interpolation(abs_score, adaptive_period, extreme_percentile)

// Ensure minimum threshold (avoid triggering on noise)
adaptive_alert_threshold := math.max(adaptive_alert_threshold, 0.5)
adaptive_extreme_threshold := math.max(adaptive_extreme_threshold, adaptive_alert_threshold + 0.5)

// Select thresholds based on mode
float threshold_alert = use_adaptive ? adaptive_alert_threshold : fixed_alert
float threshold_extreme = use_adaptive ? adaptive_extreme_threshold : fixed_extreme

// ============================================================================
// MODULE 8: STATE DETECTION (REGIME CHANGES)
// ============================================================================
//
// Instead of asking "Is the score above X?", ask:
// "Has the score CHANGED significantly from recent behavior?"
//
// This catches:
// - Transition from neutral to accumulation
// - Transition from accumulation to distribution
// - Sudden spikes in either direction
//
// More useful for timing entries/exits than absolute levels.
// ============================================================================

// Smoothed score for state detection
float state_score = ta.ema(composite_score, state_smooth)
float state_score_prev = ta.ema(composite_score[1], state_smooth)

// Rate of change in state
float state_velocity = state_score - state_score_prev
float state_velocity_z = zscore(state_velocity, zscore_period)

// State change detection
bool state_shift_bullish = use_state_detection and state_velocity_z > state_change_threshold
bool state_shift_bearish = use_state_detection and state_velocity_z < -state_change_threshold

// Define market states
var int market_state = 0  // -2: extreme dist, -1: dist, 0: neutral, 1: accum, 2: extreme accum

if composite_score >= threshold_extreme
    market_state := 2
else if composite_score >= threshold_alert
    market_state := 1
else if composite_score <= -threshold_extreme
    market_state := -2
else if composite_score <= -threshold_alert
    market_state := -1
else
    market_state := 0

// State transition detection
int prev_state = market_state[1]
bool state_changed = market_state != prev_state

// ============================================================================
// MODULE 9: ZONE CLASSIFICATION
// ============================================================================

bool is_extreme_accumulation = composite_score >= threshold_extreme
bool is_accumulation = composite_score >= threshold_alert and composite_score < threshold_extreme
bool is_neutral = math.abs(composite_score) < threshold_alert
bool is_distribution = composite_score <= -threshold_alert and composite_score > -threshold_extreme
bool is_extreme_distribution = composite_score <= -threshold_extreme

color bar_color = is_extreme_accumulation ? color_extreme_bull : is_accumulation ? color_bullish : is_extreme_distribution ? color_extreme_bear : is_distribution ? color_bearish : color_neutral

// ============================================================================
// MODULE 10: VISUALIZATION
// ============================================================================

// Zero line
hline(0, "Zero", color.gray, hline.style_solid)

// Adaptive bands (dynamic)
plot(show_adaptive_bands and use_adaptive ? threshold_alert : na, "Adaptive +Alert", color=color.new(color.green, 70), style=plot.style_stepline)
plot(show_adaptive_bands and use_adaptive ? -threshold_alert : na, "Adaptive -Alert", color=color.new(color.red, 70), style=plot.style_stepline)
plot(show_adaptive_bands and use_adaptive ? threshold_extreme : na, "Adaptive +Extreme", color=color.new(color.lime, 80), style=plot.style_stepline)
plot(show_adaptive_bands and use_adaptive ? -threshold_extreme : na, "Adaptive -Extreme", color=color.new(color.maroon, 80), style=plot.style_stepline)

// Fixed reference lines (always shown for context)
hline(2.0, "+2σ ref", color.new(color.gray, 85), hline.style_dotted)
hline(-2.0, "-2σ ref", color.new(color.gray, 85), hline.style_dotted)

// Background zones
color bg_color = is_extreme_accumulation ? color.new(color.lime, 90) : is_extreme_distribution ? color.new(color.maroon, 90) : na
bgcolor(bg_color)

// State change markers
plotshape(state_shift_bullish, "Bullish Shift", shape.triangleup, location.bottom, color.new(color.green, 30), size=size.tiny)
plotshape(state_shift_bearish, "Bearish Shift", shape.triangledown, location.top, color.new(color.red, 30), size=size.tiny)

// Main histogram
plot(show_histogram ? composite_score : na, "OFA Score", color=bar_color, style=plot.style_histogram, linewidth=3)

// Score line
plot(composite_score, "Score Line", color=bar_color, linewidth=2)

// Component scores (optional)
plot(show_components ? activity_anomaly : na, "Activity Anomaly", color=color.new(color.blue, 50), linewidth=1)
plot(show_components ? direction_anomaly : na, "Direction Anomaly", color=color.new(color.purple, 50), linewidth=1)

// ============================================================================
// MODULE 11: ALERT CONDITIONS
// ============================================================================

// Threshold-based alerts
bool alert_accumulation = ta.crossover(composite_score, threshold_alert) and barstate.isconfirmed
bool alert_distribution = ta.crossunder(composite_score, -threshold_alert) and barstate.isconfirmed
bool alert_extreme_buy = ta.crossover(composite_score, threshold_extreme) and barstate.isconfirmed
bool alert_extreme_sell = ta.crossunder(composite_score, -threshold_extreme) and barstate.isconfirmed

// State change alerts
bool alert_state_bullish = state_shift_bullish and barstate.isconfirmed
bool alert_state_bearish = state_shift_bearish and barstate.isconfirmed
bool alert_state_change = state_changed and barstate.isconfirmed

alertcondition(alert_accumulation, title="Accumulation", message="OFA2: Accumulation zone entered")
alertcondition(alert_distribution, title="Distribution", message="OFA2: Distribution zone entered")
alertcondition(alert_extreme_buy, title="Extreme Buy", message="OFA2: EXTREME accumulation detected")
alertcondition(alert_extreme_sell, title="Extreme Sell", message="OFA2: EXTREME distribution detected")
alertcondition(alert_state_bullish, title="Bullish State Shift", message="OFA2: Bullish regime change detected")
alertcondition(alert_state_bearish, title="Bearish State Shift", message="OFA2: Bearish regime change detected")
alertcondition(alert_state_change, title="Any State Change", message="OFA2: Market state changed")

// ============================================================================
// MODULE 12: INFO TABLE
// ============================================================================

var table info_table = table.new(position.top_right, 2, 9, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast
    table.cell(info_table, 0, 0, "OFA Score", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, str.tostring(composite_score, "#.##"), text_color=bar_color, text_size=size.small)

    table.cell(info_table, 0, 1, "Activity Anom.", text_color=color.white, text_size=size.small)
    color act_color = activity_anomaly > anomaly_gate ? color.yellow : color.gray
    table.cell(info_table, 1, 1, str.tostring(activity_anomaly, "#.##") + "σ", text_color=act_color, text_size=size.small)

    table.cell(info_table, 0, 2, "Direction Anom.", text_color=color.white, text_size=size.small)
    color dir_color = direction_anomaly > 0 ? color.green : color.red
    table.cell(info_table, 1, 2, str.tostring(direction_anomaly, "#.##") + "σ", text_color=dir_color, text_size=size.small)

    table.cell(info_table, 0, 3, "Imbalance", text_color=color.white, text_size=size.small)
    color imb_color = imbalance_clamped > 0 ? color.green : color.red
    table.cell(info_table, 1, 3, str.tostring(imbalance_clamped * 100, "#.#") + "%", text_color=imb_color, text_size=size.small)

    table.cell(info_table, 0, 4, "Vol/Season", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 4, str.tostring(volume_normalized, "#.##") + "x", text_color=color.white, text_size=size.small)

    table.cell(info_table, 0, 5, "Alert Thresh", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 5, "±" + str.tostring(threshold_alert, "#.##"), text_color=color.gray, text_size=size.small)

    table.cell(info_table, 0, 6, "Extreme Thresh", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 6, "±" + str.tostring(threshold_extreme, "#.##"), text_color=color.gray, text_size=size.small)

    string state_text = market_state == 2 ? "EXTREME ACCUM" : market_state == 1 ? "Accumulation" : market_state == -2 ? "EXTREME DIST" : market_state == -1 ? "Distribution" : "Neutral"
    table.cell(info_table, 0, 7, "State", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 7, state_text, text_color=bar_color, text_size=size.small)

    string mode_text = use_multiplicative ? "MULT" : "ADD"
    string adapt_text = use_adaptive ? "ADAPT" : "FIXED"
    table.cell(info_table, 0, 8, "Mode", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 8, mode_text + " / " + adapt_text, text_color=color.gray, text_size=size.small)

// ============================================================================
// END OF INDICATOR v2
// ============================================================================
